*__hyper-scripter__ 是一封寫給所有腳本愛好者的情書。採中心化管理，用最自然的方式尋找你的腳本，輕鬆管理腳本歷史，並提供命令行補全。*

+ __中心化管理__：不再為四散各地的腳本頭痛
	- 一個命令，列出所有腳本
	- 不論身在檔案系統何處，都能執行/編輯/讀取每個你心愛的腳本
+ 用最自然的方式尋找你的腳本
	- 支援模糊搜尋，如 `hs msipt` = `my/script`
	- 支援時序搜尋，如 `hs -` = 最近使用的第一個腳本
	- __一致的體驗__：搜尋方式適用於所有子命令，如刪除 `rm`，讀取 `cat`，編輯 `edit`，複製 `cp` 等等
+ 輕鬆管理<b>腳本歷史</b>
	- 可查詢 `show`，刪除 `rm`，修改 `amend` 先前呼叫腳本時使用的命令行參數
+ 以標籤和時間分類
	- 藉由切換標籤，快速<b>切換你的工作狀態</b>
	- 自動隱藏太久沒動的腳本
+ 命令行補全功能

## 工作自動化之辯
<b>工作自動化</b>是個有些籠統的名詞，只要你寫了第一行腳本，工作便具有自動化的成份（甚至，有任何依賴電腦的工作能說是純手動的嗎？）。為了避免討論失焦，不妨將工作自動化定義為 `jenkins` `ansible` `cron job` 這類工具所標榜的<b>可穩定重現、可版控</b>的自動化。

在此種定義下，__hyper-scripter__ 並非一個工作自動化工具，它的使用情境包括：

- 輕易修改/刪除腳本
- 建立一些你絕不想存進版控的骯髒腳本，執行幾次後再毫不留情地砍掉
- 查一下之前都怎麼跑某個腳本，微調參數後再跑一次
- 利用標籤與時間，篩選掉你暫時不感興趣的腳本，得以專注在重要的少數工作上
- 其它……

這些都不利於穩定的自動化，我們也不鼓勵你將它用做（唯一的）工作自動化工具，然而：

1. 並非所有工作都需要自動化 [^1]
2. 自動化之前，瞭解哪些工作流程時常變動、哪些工作是熱點、這些工作的參數通常都是什麼……都非常有助於你真正將它們自動化

而這正是 __hyper-scripter__ 設計的核心考量。因此我們認為，即使你是個工作自動化偏執狂（稱讚意味），它仍然可以成為你工作中的堅強戰力。

[^1]: 比方說，有個專案存放在你自己家目錄中，例如 `/home/myname/Workspace/prj`。而為了自己測試方便，你想用一個 tmux session 將它分別編譯成 64-bit release 和 32-bit debug 版……這種工作真的需要嚴謹的自動化嗎？